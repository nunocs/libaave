/*
 * libaave/reverb_dattorro.c: Dattorro artificial reverberation tail
 *
 * Copyright 2013 Universidade de Aveiro
 *
 * Funded by FCT project AcousticAVE (PTDC/EEA-ELC/112137/2009)
 *
 * Written by:
 * Andre B. Oliveira <abo@ua.pt>
 * Nuno Miguel Silva <nunomiguelsilva@ua.pt>
 */

/**
 * @file reverb_dattorro.c
 *
 * The reverb_dattorro.c file implements a Dattorro reverberator
 * to add an artificial reverberation tail to the output of the auralisation
 * generated by the audio.c part of the auralisation process, to simulate
 * the late reflections that the geometry.c part of the auralisation process
 * could not determine in time.
 *
 * @todo Make the code reentrant (move the static structures to aave).
 *
 * Reference:
 * Jon Dattorro, "Effect Design, Part 1: Reverberator and Other Filters",
 * J. Audio Eng. Soc (AES), Vol. 45, No 9, Sep 1997.
 */

#include "aave.h"

/** Pre-delay, in number of samples (150ms). */
#define PREDELAY (0.15 * AAVE_FS)

/** Bandwidth of the early low-pass filter. */
#define BANDWIDTH 0.7

/** Input diffusion gains of the early all-pass filters. */
#define INPUT_DIFFUSION_1 0.65
#define INPUT_DIFFUSION_2 0.6

/** Decay diffusion gain of the late all-pass filters. */
#define DECAY_DIFFUSION_1 0.625
#define DECAY_DIFFUSION_2 0.7

/** Decay parameter. */
#define DECAY 0.8

/** Damping of the late low-pass filters. */
#define DAMPING 0.7

/** Gain of the wet path of the reverberator. */
#define WET 0.3

/**
 * Data of a delay block.
 */
struct delay {

	/** Index to the latest value inserted in the buffer. */
	unsigned index;

	/**
	 * Buffer to store the inserted values.
	 * @todo Set maximum delay from the delays of all delay blocks.
	 */
	float buffer[16384];
};

/**
 * Data of a low-pass filter.
 */
struct lowpass {

	/** Previous output of the filter (y[n-1]). */
	float y;
};

/**
 * Data of an all-pass filter.
 */
struct allpass {

	/** Value captured inside the feedback network. */
	float tap;

	/** Index to the latest value inserted in the buffer. */
	unsigned index;

	/**
	 * Buffer to store the inserted values.
	 * @todo Set maximum delay from the delays of all all-pass blocks.
	 */
	float buffer[2656];
};

/**
 * Data of a decay block.
 */
struct decay_block {

	/** The previous output value. */
	float out;

	/** The dampping low-pass filter. */
	struct lowpass lp;

	/** The decay all-pass filters. */
	struct allpass ap[2];

	/** The delay lines. */
	struct delay delay[2];
};

/**
 * Execute a delay block: y[n] = x[n - k].
 * @p d is the delay block data,
 * @p x is the input value, and
 * @p k is the number of samples of delay.
 * Returns the output value y[n].
 */
static float delay(struct delay *d, float x, unsigned k)
{
	float y;
	unsigned i;

	i = (d->index + 1) % k;
	d->index = i;

	y = d->buffer[i];
	d->buffer[i] = x;

	return y;
}

/**
 * Execute a low-pass filter: y[n] = b * x[n] + (1 - b) * y[n-1].
 * @p lp is the low-pass filter data,
 * @p x is the input value,
 * @p b is the bandwidth/damping coefficient.
 * Returns the output value y[n].
 */
static float lowpass(struct lowpass *lp, float x, float b)
{
	lp->y = b * x + (1 - b) * lp->y;

	return lp->y;
}

/**
 * Execute an all-pass filter: H(z) = (g + z^-k) / (1 + g z^-k).
 * @p ap is the all-pass filter data,
 * @p x is the input value,
 * @p g is the gain coefficient, and
 * @p delay is the number of samples of delay.
 * Returns the output value of the all-pass filter.
 */
static float allpass(struct allpass *ap, float x, float g, unsigned delay)
{
	float x1, x2;
	unsigned index;

	index = (ap->index + 1) % delay;
	ap->index = index;

	x2 = ap->buffer[index];
	x1 = x - g * x2;
	ap->buffer[index] = x1;
	ap->tap = x1; /** @todo Check if the tap is really x1 or x2. */
	return x1 * g + x2;
}

/**
 * Execute a decay block.
 * @p b is the decay block data,
 * @p x is the input value,
 * @p i is the index of the decay block parameters to use (0 or 1), and
 * @p out1, @p out2, @p out3 are the output taps.
 */
static void decay_block(struct decay_block *b, float x, unsigned i,
			float *out1, float *out2, float *out3)
{
	static const struct {
		float ap0_delay;
		unsigned delay0;
		float ap1_delay;
		unsigned delay1;
	} param[] = {
		{ 672, 4453, 1800, 3720 },
		{ 908, 4217, 2656, 3163 }
	};

	x = allpass(&b->ap[0], x, DECAY_DIFFUSION_1, param[i].ap0_delay);
	*out1 = x;
	x = delay(&b->delay[0], x, param[i].delay0);
	x = lowpass(&b->lp, x, DAMPING);
	x *= DECAY;
	*out2 = x; /**/
	x = allpass(&b->ap[1], x, DECAY_DIFFUSION_2, param[i].ap1_delay);
	*out3 = b->ap[1].tap;
	x = delay(&b->delay[1], x, param[i].delay1);
	x *= DECAY;
	b->out = x;
}

/**
 * Run a Dattorro reverberator to add an artificial reverberation tail
 * to the @p n binaural frames (2 * @p n samples) pointed by @p audio.
 */
void aave_reverb_dattorro(struct aave *aave, short *audio, unsigned n)
{
	static struct delay predelay;
	static struct lowpass lp1;
	static struct allpass ap[4];
	static struct delay d[14];
	static struct decay_block b[2];
	float x, xl, xr, out[6];
	unsigned i;

	for (i = 0; i < n; i++) {
		x = (audio[i*2] + audio[i*2+1]) * 0.5;

		x = delay(&predelay, x, PREDELAY);

		x = lowpass(&lp1, x, BANDWIDTH);

		x = allpass(&ap[0], x, INPUT_DIFFUSION_1, 142);
		x = allpass(&ap[1], x, INPUT_DIFFUSION_1, 107);
		x = allpass(&ap[2], x, INPUT_DIFFUSION_2, 379);
		x = allpass(&ap[3], x, INPUT_DIFFUSION_2, 277);

		xl = b[0].out;
		xr = b[1].out;

		decay_block(&b[0], x + xr, 0, &out[0], &out[1], &out[2]);
		decay_block(&b[1], x + xl, 1, &out[3], &out[4], &out[5]);

		/* left */
		audio[i * 2 + 0] = audio[i * 2 + 0] + WET * (
			- delay(&d[2], out[0], 1990)
			- delay(&d[4], out[1], 187)
			- delay(&d[6], out[2], 1066)
			+ delay(&d[8], out[3], 2974)
			+ delay(&d[9], out[3], 266)
			- delay(&d[11], out[4], 1913)
			+ delay(&d[13], out[5], 1996));

		/* right */
		audio[i * 2 + 1] = audio[i * 2 + 1] + WET * (
			+ delay(&d[0], out[0], 353)
			+ delay(&d[1], out[0], 3627)
			- delay(&d[3], out[1], 1228)
			+ delay(&d[5], out[2], 2673)
			- delay(&d[7], out[3], 2111)
			- delay(&d[10], out[4], 335)
			- delay(&d[12], out[5], 121));
	}
}
